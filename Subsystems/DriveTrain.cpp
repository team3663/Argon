// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#define ACCEL_LIMIT 0.05
#define DECEL_LIMIT 0.2
#define PI 				3.14159
#define ENCODER_CORRECT 4 * 12 / 22 / 1440
#include "DriveTrain.h"
#include "../Robotmap.h"
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	speedControlLeft1 = RobotMap::driveTrainSpeedControlLeft1;
	speedControlLeft2 = RobotMap::driveTrainSpeedControlLeft2;
	speedControlRight1 = RobotMap::driveTrainSpeedControlRight1;
	speedControlRight2 = RobotMap::driveTrainSpeedControlRight2;
	leftEncoder = RobotMap::driveTrainLeftEncoder;
	rightEncoder = RobotMap::driveTrainRightEncoder;
	gyro = RobotMap::driveTrainGyro;
	robotDrive3663 = RobotMap::driveTrainRobotDrive3663;
	gearShift1 = RobotMap::driveTrainGearShift1;
	gearShift2 = RobotMap::driveTrainGearShift2;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	robotDrive3663->SetSafetyEnabled(false);
	highGear = true;
	//RobotMap::targettingLedSwitch->Set(Relay::kForward);
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::Arcade()
{
	
	//robotDrive3663->ArcadeDrive(Robot::oi->getDriveJoystick()->GetY(), Robot::oi->getDriveJoystick()->GetX());
	
	static float prevMoveValue = 0;
	static float prevRotateValue = 0;
	
	float moveValue = Robot::oi->getDriveJoystick()->GetY();
	float rotateValue = Robot::oi->getDriveJoystick()->GetX();
	
	//if (prevMoveValue > 0.3 || prevMoveValue < -0.3)
	{
		if (moveValue > (prevMoveValue + ACCEL_LIMIT))
		{
			moveValue = prevMoveValue + ACCEL_LIMIT;
		}
		else if (moveValue < prevMoveValue - DECEL_LIMIT)
		{
			moveValue = prevMoveValue - DECEL_LIMIT;
		}
	}
	/*else
	{
		moveValue = Robot::oi->getDriveJoystick()->GetY();
	}*/
		
	//if (prevRotateValue > 0.3 || prevRotateValue < -0.3)
	{
		if (rotateValue > (prevRotateValue + ACCEL_LIMIT))
		{
			rotateValue = prevRotateValue + ACCEL_LIMIT;
		}
		else if (rotateValue < prevRotateValue - DECEL_LIMIT)
		{
			rotateValue = prevRotateValue - DECEL_LIMIT;
		}
	}
	/*else
	{
		rotateValue = Robot::oi->getDriveJoystick()->GetX();
	}*/
	
	prevMoveValue = moveValue;
	prevRotateValue = rotateValue;
	robotDrive3663->ArcadeDrive(-moveValue, -rotateValue);
}
void DriveTrain::GearShift(bool shift){
	if(Robot::oi->GetX() < 0.1 && Robot::oi->GetX() > -0.1 && Robot::oi->GetY() > -0.1 && Robot::oi->GetY() < 0.1){
	gearShift1->Set(shift);
	gearShift2->Set(!shift);
	highGear = shift;
	}
}

void DriveTrain::ResetGyro()
{
	gyro->Reset();
}

void DriveTrain::Drive(float speed, float curve)
{
	robotDrive3663->ArcadeDrive(speed,curve);
}
void DriveTrain::Stop(){
	Drive(0,0);
}

float DriveTrain::GetAngle()
{
	return gyro->GetAngle();
}
bool DriveTrain::GetGearState()
{
	return highGear;
}
float DriveTrain::GetRotations(){
	float encodeRight = rightEncoder->GetDistance()*PI*ENCODER_CORRECT;
	return encodeRight;
}
void DriveTrain::UpdateStatus()
{
	SmartDashboard::PutNumber("Right Encoder:", GetRotations());
	SmartDashboard::PutNumber("Gyro", GetAngle());
	if (highGear)
		SmartDashboard::PutString("Transmission:", "High Gear");
	else
		SmartDashboard::PutString("Transmission:", "Low Gear");
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

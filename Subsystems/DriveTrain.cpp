// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#define ACCEL_LIMIT 0.05
#define DECEL_LIMIT 0.2
#define PI 				3.14159
#define ENCODER_CORRECT 4 * 12 / 22 / 1440
#include "DriveTrain.h"
#include "../Robotmap.h"
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	speedControlLeft1 = RobotMap::driveTrainSpeedControlLeft1;
	speedControlLeft2 = RobotMap::driveTrainSpeedControlLeft2;
	speedControlRight1 = RobotMap::driveTrainSpeedControlRight1;
	speedControlRight2 = RobotMap::driveTrainSpeedControlRight2;
	leftEncoder = RobotMap::driveTrainLeftEncoder;
	rightEncoder = RobotMap::driveTrainRightEncoder;
	gyro = RobotMap::driveTrainGyro;
	robotDrive3663 = RobotMap::driveTrainRobotDrive3663;
	gearShift1 = RobotMap::driveTrainGearShift1;
	gearShift2 = RobotMap::driveTrainGearShift2;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	robotDrive3663->SetSafetyEnabled(false);
	highGear = true;
	encodeRightPrevious = 0.0;
	encodeLeftPrevious = 0.0;
	//RobotMap::targettingLedSwitch->Set(Relay::kForward);
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::Arcade()
{
	
	static float prevMoveValue = 0;
	static float prevRotateValue = 0;
	
	float moveValue = Robot::oi->getDriveJoystick()->GetY();
	float rotateValue = Robot::oi->getDriveJoystick()->GetX();
	
	if (moveValue > (prevMoveValue + ACCEL_LIMIT))
	{
		moveValue = prevMoveValue + ACCEL_LIMIT;
	}
	else if (moveValue < prevMoveValue - DECEL_LIMIT)
	{
		moveValue = prevMoveValue - DECEL_LIMIT;
	}
	
	if (rotateValue > (prevRotateValue + ACCEL_LIMIT))
	{
		rotateValue = prevRotateValue + ACCEL_LIMIT;
	}
	else if (rotateValue < prevRotateValue - DECEL_LIMIT)
	{
		rotateValue = prevRotateValue - DECEL_LIMIT;
	}
	
	prevMoveValue = moveValue;
	prevRotateValue = rotateValue;
	robotDrive3663->ArcadeDrive(-moveValue, -rotateValue);
}

void DriveTrain::GearShift(bool shift){
	if(Robot::oi->GetX() < 0.1 && Robot::oi->GetX() > -0.1 && Robot::oi->GetY() > -0.1 && Robot::oi->GetY() < 0.1){
	gearShift1->Set(shift);
	gearShift2->Set(!shift);
	highGear = shift;
	}
}

void DriveTrain::ResetGyro()
{
	gyro->Reset();
}

void DriveTrain::Drive(float speed, float curve)
{
	robotDrive3663->ArcadeDrive(-speed,curve);
}
void DriveTrain::Stop(){
	Drive(0,0);
}

float DriveTrain::GetAngle()
{
	return gyro->GetAngle();
}
bool DriveTrain::GetGearState()
{
	return highGear;
}

float DriveTrain::GetLeftDistance(){
	
	static float encodeLeftChange = (leftEncoder->GetDistance()*PI*ENCODER_CORRECT) - encodeLeftPrevious;
	return encodeLeftChange;
}

float DriveTrain::GetRightDistance(){

	float encodeRightChange = (rightEncoder->GetDistance()*PI*ENCODER_CORRECT) - encodeRightPrevious;
	return encodeRightChange;
}

void DriveTrain::DriveEncoderReset(){
	encodeRightPrevious = rightEncoder->GetDistance()*PI*ENCODER_CORRECT;
	encodeLeftPrevious = leftEncoder->GetDistance()*PI*ENCODER_CORRECT;
}

void DriveTrain::UpdateStatus()
{
	SmartDashboard::PutNumber("Right Encoder:", GetRightDistance());
	SmartDashboard::PutNumber("Gyro", GetAngle());
	if (highGear)
		SmartDashboard::PutString("Transmission:", "High Gear");
	else
		SmartDashboard::PutString("Transmission:", "Low Gear");
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

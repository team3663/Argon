// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "EncoderDriveToCommand.h"
EncoderDriveToCommand::EncoderDriveToCommand(float finishPoint) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain);
	destination = finishPoint;
	
	driveSpeed = 0;
	curve = 0;
	driveProgress = 0;
	start = true;
	
	SetTimeout(10.0);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
// Called just before this Command runs the first time
void EncoderDriveToCommand::Initialize() {
	//check how far we want to go and make it out of 100%
	//limit power to 80% max
	//increase speed up until 50% then decrease
	
	Robot::driveTrain->DriveEncoderReset();
	start = true;

	Robot::driveTrain->Drive(0.75,0);
	Wait(1.5);
	
}
// Called repeatedly when this Command is scheduled to run
void EncoderDriveToCommand::Execute() {
	
	driveProgress = Robot::driveTrain->GetRightDistance() / destination;
	
	if (driveProgress > 1)
	{
		driveProgress = 1;
	}

	if (driveProgress < 0.5)
	{
		driveSpeed = driveProgress;
	}
	else if (driveProgress > 0.5 && driveProgress < 1.0)
	{
		driveSpeed = 1 - driveProgress;
	}
	else if (driveProgress >= 1)
	{
		driveSpeed = 0;
		start = false;
	}

	//driveSpeed = driveSpeed * 0.8;
	
	DriverStationLCD::GetInstance()->PrintfLine(DriverStationLCD::kUser_Line5, "DriveSpeed: %f", driveSpeed);
	DriverStationLCD::GetInstance()->UpdateLCD();

	curve = (Robot::driveTrain->GetLeftDistance() / Robot::driveTrain->GetLeftDistance()) - 1;

	Robot::driveTrain->Drive(driveSpeed,curve);
}
// Make this return true when this Command no longer needs to run execute()
bool EncoderDriveToCommand::IsFinished() {
	return !start || IsTimedOut();
}
// Called once after isFinished returns true
void EncoderDriveToCommand::End() {}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void EncoderDriveToCommand::Interrupted() {
	End();
}

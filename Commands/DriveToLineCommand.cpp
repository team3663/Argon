// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveToLineCommand.h"
DriveToLineCommand::DriveToLineCommand(float distanceToDrive, float maxSpeed, int decay) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain);
	
	driveSpeed      = 0;      // speed value for robot drive
	_maxSpeed        = maxSpeed;    // maximum speed for driving
	curve           = 0;      // curve value for robot drive
	driveProgress   = 0;      // distance traveled so far
	decayFactor     = decay;      // how rapidly to decrease speed as approaching target
	reachedEndpoint = false;  // whether command is completed or not
	driveDistance = distanceToDrive;
	
	SetTimeout(10.0);  // set the command to end at 10 seconds if not yet completed
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

void DriveToLineCommand::Initialize() {
	//check how far we want to go and make it out of 100%
	//limit power to 80% max
	//increase speed up until 50% then decrease
	
	Robot::driveTrain->DriveEncoderReset();  // reset encoder to zero to start;
	Robot::driveTrain->Drive(0.75,0);        // short drive to start the encoder counting
	Wait(0.5);                               // drive a half second
}

void DriveToLineCommand::Execute() {
	// check distance traveled relative to total distance to drive (value always < 1 ) 
	driveProgress = Robot::driveTrain->GetRightDistance();
	if (driveProgress >= driveDistance) {
		driveSpeed = 0;  // done driving, we are past the target point
		reachedEndpoint = true;
	}
	// if we haven't reached target point, set drive speed
	driveSpeed = ((driveDistance - driveProgress)/driveDistance) * decayFactor * _maxSpeed;
	if (driveSpeed > 1.0) driveSpeed  = _maxSpeed; // just in case, make sure it doesn't drive too fast
	if (driveSpeed < 0.20) driveSpeed = 0.20;     // don't drive any slower than that or it doesn't move
    // check that both encoders are measuring the same
	// This creates a ratio around 1, then subtracts to make it vary around 0 instead
	// Use this as the correcting curve in the drive command
	curve = (Robot::driveTrain->GetRightDistance() / Robot::driveTrain->GetLeftDistance()) - 1;
	Robot::driveTrain->Drive(driveSpeed,curve);
	
	DriverStationLCD::GetInstance()->PrintfLine(DriverStationLCD::kUser_Line4, "DriveSpeed: %f", driveSpeed);
	DriverStationLCD::GetInstance()->UpdateLCD();
}
// Make this return true when this Command no longer needs to run execute()
bool DriveToLineCommand::IsFinished() {
	return reachedEndpoint || IsTimedOut() || Robot::photoelectric->GetCurrentStatus();  // returns true if endpoint or timed out
}
// Called once after isFinished returns true
void DriveToLineCommand::End() {
	// we should stop the drive here
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveToLineCommand::Interrupted() {
	End();
}
